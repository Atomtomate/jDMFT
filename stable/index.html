<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Home · jDMFT</title><script data-outdated-warner src="assets/warner.js"></script><link rel="canonical" href="https://Atomtomate.github.io/jDMFT.jl/"/><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.045/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.13.24/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="assets/documenter.js"></script><script src="siteinfo.js"></script><script src="../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><div class="docs-package-name"><span class="docs-autofit"><a href>jDMFT</a></span></div><form class="docs-search" action="search/"><input class="docs-search-query" id="documenter-search-query" name="q" type="text" placeholder="Search docs"/></form><ul class="docs-menu"><li class="is-active"><a class="tocitem" href>Home</a><ul class="internal"><li><a class="tocitem" href="#Index"><span>Index</span></a></li><li><a class="tocitem" href="#Autodocs"><span>Autodocs</span></a></li></ul></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><nav class="breadcrumb"><ul class="is-hidden-mobile"><li class="is-active"><a href>Home</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Home</a></li></ul></nav><div class="docs-right"><a class="docs-edit-link" href="https://github.com/Atomtomate/jDMFT.jl/blob/master/docs/src/index.md#L" title="Edit on GitHub"><span class="docs-icon fab"></span><span class="docs-label is-hidden-touch">Edit on GitHub</span></a><a class="docs-settings-button fas fa-cog" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-sidebar-button fa fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a></div></header><article class="content" id="documenter-page"><h1 id="jDMFT.jl-Documentation"><a class="docs-heading-anchor" href="#jDMFT.jl-Documentation">jDMFT.jl Documentation</a><a id="jDMFT.jl-Documentation-1"></a><a class="docs-heading-anchor-permalink" href="#jDMFT.jl-Documentation" title="Permalink"></a></h1><p>Small demonstration of a Dynamical Mean Field Theory (DMFT) solver with some examples of impurity solvers included. For now there is a IteratedPerturbation Theory (IPT) and continuous time quantum Monte Carlo, interaction expansion (CT-INT), solver available.</p><p>TODO: at some point I should provide some actual documentation here.</p><ul><li><a href="#jDMFT.jl-Documentation">jDMFT.jl Documentation</a></li><li class="no-marker"><ul><li><a href="#Index">Index</a></li><li><a href="#Autodocs">Autodocs</a></li></ul></li></ul><h2 id="Index"><a class="docs-heading-anchor" href="#Index">Index</a><a id="Index-1"></a><a class="docs-heading-anchor-permalink" href="#Index" title="Permalink"></a></h2><ul><li><a href="#jDMFT.CTInt_Confs"><code>jDMFT.CTInt_Confs</code></a></li><li><a href="#jDMFT.MatsubaraFunction"><code>jDMFT.MatsubaraFunction</code></a></li><li><a href="#jDMFT.Measurements-Tuple{Int64, Float64, Symbol}"><code>jDMFT.Measurements</code></a></li><li><a href="#jDMFT.Measurements"><code>jDMFT.Measurements</code></a></li><li><a href="#jDMFT.SampleMatrix"><code>jDMFT.SampleMatrix</code></a></li><li><a href="#jDMFT.τFunction"><code>jDMFT.τFunction</code></a></li><li><a href="#jDMFT.accumulate!-Tuple{Random.AbstractRNG, jDMFT.Measurements, Int64, jDMFT.CTInt_Confs, jDMFT.SampleMatrix}"><code>jDMFT.accumulate!</code></a></li><li><a href="#jDMFT.draw_Gτ-Tuple{τFunction, Float64}"><code>jDMFT.draw_Gτ</code></a></li><li><a href="#jDMFT.fast_update_decr!-Tuple{jDMFT.SampleMatrix, Int64}"><code>jDMFT.fast_update_decr!</code></a></li><li><a href="#jDMFT.fast_update_incr!-Tuple{jDMFT.SampleMatrix, Int64}"><code>jDMFT.fast_update_incr!</code></a></li><li><a href="#jDMFT.gaussradau-Tuple{Real, Real, Int64}"><code>jDMFT.gaussradau</code></a></li><li><a href="#jDMFT.impSolve_IPT-Tuple{τFunction, τFunction, Vector{ComplexF64}, Float64, Float64}"><code>jDMFT.impSolve_IPT</code></a></li><li><a href="#jDMFT.measure_GImp_τ-Tuple{jDMFT.Measurements, τFunction}"><code>jDMFT.measure_GImp_τ</code></a></li><li><a href="#jDMFT.riemann-Tuple{Real, Real, Int64}"><code>jDMFT.riemann</code></a></li><li><a href="#jDMFT.subtract_tail!-Union{Tuple{T}, Tuple{AbstractVector{T}, AbstractVector{T}, Vector{Float64}, Vector{ComplexF64}}} where T&lt;:Number"><code>jDMFT.subtract_tail!</code></a></li><li><a href="#jDMFT.τGridTransform-Tuple{Real, Real, Vector{Float64}}"><code>jDMFT.τGridTransform</code></a></li><li><a href="#jDMFT.τIndex-Tuple{Float64, Vector{Float64}, Float64}"><code>jDMFT.τIndex</code></a></li><li><a href="#jDMFT.τIntegrate-Tuple{AbstractVector, Vector, Vector{Float64}}"><code>jDMFT.τIntegrate</code></a></li><li><a href="#jDMFT.τ_to_ω-Tuple{τFunction, Vector{ComplexF64}}"><code>jDMFT.τ_to_ω</code></a></li><li><a href="#jDMFT.ω_to_τ-Tuple{MatsubaraFunction, AbstractVector, AbstractVector}"><code>jDMFT.ω_to_τ</code></a></li></ul><h2 id="Autodocs"><a class="docs-heading-anchor" href="#Autodocs">Autodocs</a><a id="Autodocs-1"></a><a class="docs-heading-anchor-permalink" href="#Autodocs" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-binding" id="jDMFT.CTInt_Confs" href="#jDMFT.CTInt_Confs"><code>jDMFT.CTInt_Confs</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">CTInt_Confs</code></pre><p><strong>Fields</strong></p><ul><li><strong><code>β</code></strong>         : <code>Float64</code>, inverse temperature</li><li><strong><code>U</code></strong>         : <code>Float64</code>, interaction strenght</li><li><strong><code>δ</code></strong>         : <code>Float64</code>, numerical stabilization parameter for sample matrix</li><li><strong><code>GWeiss</code></strong>    : <code>τFunction</code>, noninteracting impurity Green&#39;s function</li><li><strong><code>τList</code></strong>     : <code>Array{Float64}</code>, τ values on which the Green&#39;s function is evaluated</li><li><strong><code>τiList</code></strong>    : <code>Array{Float64}</code>, sampled τ, i-th entry corresponds to i-th row/column in <a href="#jDMFT.SampleMatrix"><code>SampleMatrix</code></a></li><li><strong><code>siList</code></strong>    : <code>Array{Int}</code>, external ising field, i-th entry corresponds to i-th row/column in <a href="#jDMFT.SampleMatrix"><code>SampleMatrix</code></a></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Atomtomate/jDMFT.jl/blob/7b44f4eeaf5c8f29c2699c176ff0979a5d498755/src/CTINT_measure.jl#LL61-L73">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="jDMFT.MatsubaraFunction" href="#jDMFT.MatsubaraFunction"><code>jDMFT.MatsubaraFunction</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">MatsubaraFunction</code></pre><p>Holds data for a function over Matsubara frequencies and associated information. </p><p><strong>Fields</strong></p><ul><li><strong><code>data</code></strong>        : <code>Vector{ComplexF64}</code>, data</li><li><strong><code>β</code></strong>           : <code>Float64</code>, inverse temperature</li><li><strong><code>fGrid</code></strong>       : <code>Vector{ComplexF64}</code>, x-values (i.e., frequence grid), <span>$\frac{(2n+1) \pi}{\beta}$</span> for fermionic grids and <span>$\frac{(2n) \pi}{\beta}$</span> for bosonic grids. </li><li><strong><code>tail_coeffs</code></strong> : <code>AbstractVector</code>, first <code>N</code> tail coefficients of the high frequency expansion <span>$\sum_{i=0}^N\frac{c_i}{i\nu^i_n}$</span>.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Atomtomate/jDMFT.jl/blob/7b44f4eeaf5c8f29c2699c176ff0979a5d498755/src/GFTools.jl#LL39-L50">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="jDMFT.Measurements" href="#jDMFT.Measurements"><code>jDMFT.Measurements</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">Measurements</code></pre><p>Accumulation helper, see Gull et al., 2008.</p><p>#TODO: this should be generalized to allow histograms and bootstrapping, e.g. dict of functors</p><p><strong>Fields</strong></p><ul><li><strong><code>samples</code></strong>      : <code>Vector{ComplexF64}</code>, List of all samples</li><li><strong><code>τGrid</code></strong>        : <code>Vector{Float64}</code>, sampling points for τ</li><li><strong><code>NSamples</code></strong>     : <code>Int</code>, number of samples</li><li><strong><code>totalSign</code></strong>    : <code>Int</code>, total Monte Carlo sign.</li><li><strong><code>totalExpOrder</code></strong>  : <code>Int</code>, sum of expansion orders</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Atomtomate/jDMFT.jl/blob/7b44f4eeaf5c8f29c2699c176ff0979a5d498755/src/CTINT_measure.jl#LL20-L34">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="jDMFT.Measurements-Tuple{Int64, Float64, Symbol}" href="#jDMFT.Measurements-Tuple{Int64, Float64, Symbol}"><code>jDMFT.Measurements</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">Measurements(NBins::Int, β::Float64, type::Symbol)</code></pre><p>Generates a Measurements struct for a temperature <code>β</code> with <code>NBins</code> bins and of grid type <code>type</code> which may be:</p><ul><li>&#39;GaussQuad&#39; : generates a Gauss Radau grid and its corresponding τWeights</li><li>&#39;Riemann&#39;   : generates an evenly distriubted grid where each point has equal weight</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Atomtomate/jDMFT.jl/blob/7b44f4eeaf5c8f29c2699c176ff0979a5d498755/src/CTINT_measure.jl#LL43-L49">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="jDMFT.SampleMatrix" href="#jDMFT.SampleMatrix"><code>jDMFT.SampleMatrix</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">SampleMatrix</code></pre><p>Holds samples data for f(τ<em>ij) in each matrix entry. f depends on the algrithm (Weiss GF for CT-INT, Δ for CT</em>HYB). This should be used in conjunction with the config struct (wich saves the τ_ij and additional data) for the specific sampler.</p><p><strong>Fields</strong></p><ul><li><strong><code>data</code></strong>        : <code>Matrix{ComplexF64}</code>, Data for sample matrix</li><li><strong><code>rowCache</code></strong>    : <code>Vector{ComplexF64}</code>, Row cache for potential new size</li><li><strong><code>colCache</code></strong>    : <code>Vector{ComplexF64}</code>, Column cache for potential new size</li><li><strong><code>S</code></strong>           : <code>Complex64</code>, Cache for bottom right entry (remaining new value besides row and colum cache)</li><li><strong><code>N</code></strong>           : <code>Int</code>, Used matrix dimension, this differs from the actual data size, due to caching, see also <a href="@ref"><code>update_cache!</code></a></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Atomtomate/jDMFT.jl/blob/7b44f4eeaf5c8f29c2699c176ff0979a5d498755/src/DataTypes.jl#LL14-L27">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="jDMFT.τFunction" href="#jDMFT.τFunction"><code>jDMFT.τFunction</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">τFunction</code></pre><p>Holds data for a function over imaginary time and associated information. </p><p><strong>Fields</strong></p><ul><li><strong><code>data</code></strong>        : <code>Vector{ComplexF64}</code>, data</li><li><strong><code>β</code></strong>           : <code>Float64</code>, inverse temperature</li><li><strong><code>τGrid</code></strong>       : <code>AbstractVector{Float64}</code>, <span>$\tau$</span>-grid, </li><li><strong><code>τWeights</code></strong>    : <code>AbstractVector{Float64}</code>, wheights for each <span>$f(\tau)$</span> point, used for integration methods.</li><li><strong><code>tail_coeffs</code></strong> : <code>AbstractVector</code>, first <code>N</code> tail coefficients of the high frequency expansion <span>$\sum_{i=0}^N\frac{c_i}{\tau}$</span>.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Atomtomate/jDMFT.jl/blob/7b44f4eeaf5c8f29c2699c176ff0979a5d498755/src/GFTools.jl#LL60-L72">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="jDMFT.accumulate!-Tuple{Random.AbstractRNG, jDMFT.Measurements, Int64, jDMFT.CTInt_Confs, jDMFT.SampleMatrix}" href="#jDMFT.accumulate!-Tuple{Random.AbstractRNG, jDMFT.Measurements, Int64, jDMFT.CTInt_Confs, jDMFT.SampleMatrix}"><code>jDMFT.accumulate!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">accumulate!(rng::AbstractRNG, m::Measurements, sign::Int, confs::CTInt_Confs, M::SampleMatrix; with_τshift=true)</code></pre><p>Updates Monte Carlo estimate by measuring impurity Green&#39;s function for given configuration stored in <code>M</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Atomtomate/jDMFT.jl/blob/7b44f4eeaf5c8f29c2699c176ff0979a5d498755/src/CTINT_measure.jl#LL113-L118">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="jDMFT.draw_Gτ-Tuple{τFunction, Float64}" href="#jDMFT.draw_Gτ-Tuple{τFunction, Float64}"><code>jDMFT.draw_Gτ</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">draw_Gτ(Gτ::τFunction, τi::Float64)::ComplexF64 
draw_Gτ(data::Vector{ComplexF64}, τi::Float64, τGrid::Vector{Float64}, β::Float64)::ComplexF64</code></pre><p>Obtain <code>f(\tau)</code> data for a function, either given as <a href="#jDMFT.τFunction"><code>τFunction</code></a> or as <code>Vector{ComplexF64}</code> at  imaginary time <code>τi</code>. Data is linearly interpolated from the given grid.</p><p>TODO: test and implement fast-version (only draw random indices) TODO: replace linear interpolation by some cubic lin. inter, using legndre grid </p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Atomtomate/jDMFT.jl/blob/7b44f4eeaf5c8f29c2699c176ff0979a5d498755/src/GFTools.jl#LL85-L94">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="jDMFT.fast_update_decr!-Tuple{jDMFT.SampleMatrix, Int64}" href="#jDMFT.fast_update_decr!-Tuple{jDMFT.SampleMatrix, Int64}"><code>jDMFT.fast_update_decr!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">fast_update_decr!(M::SampleMatrix, N::Int)</code></pre><p>Compute fast inverse update, using Woodbury matrix idenity:      <code>M_inv = inv(M)</code>     <code>Mnew_inv =</code><code>M_inv</code> after deleting right column and bottom row     <code>Mnew = inv(Mnew_inv)</code></p><p><code>N</code> is the new size. TODO: currently only rank 1 updates supported, so <code>N = M.N-1</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Atomtomate/jDMFT.jl/blob/7b44f4eeaf5c8f29c2699c176ff0979a5d498755/src/DataTypes.jl#LL69-L78">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="jDMFT.fast_update_incr!-Tuple{jDMFT.SampleMatrix, Int64}" href="#jDMFT.fast_update_incr!-Tuple{jDMFT.SampleMatrix, Int64}"><code>jDMFT.fast_update_incr!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">fast_update_incr!(M::SampleMatrix, N::Int)</code></pre><p>Compute fast inverse update, using Woodbury matrix idenity:      <code>M_inv = inv(M)</code>     <code>Mnew_inv = M_inv</code> after inserting row/col/corner obtained from <code>M.rowCach</code>, <code>M.colCache</code>, <code>M.S</code>     <code>Mnew = inv(Mnew_inv)</code></p><p><code>M.rowCache</code>, <code>M.colCache</code> and <code>M.S</code> must be set to the new values, before calling this function! <code>N</code> is the new size. TODO: currently only rank 1 updates supported, so <code>N = M.N+1</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Atomtomate/jDMFT.jl/blob/7b44f4eeaf5c8f29c2699c176ff0979a5d498755/src/DataTypes.jl#LL43-L53">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="jDMFT.gaussradau-Tuple{Real, Real, Int64}" href="#jDMFT.gaussradau-Tuple{Real, Real, Int64}"><code>jDMFT.gaussradau</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">gaussradau(start::Real, stop::Real, N::Int)</code></pre><p>Generate grid for gaussradau sum integration from <code>start</code> to <code>stop</code> with <code>N</code> points. Returns <code>(weights, grid)</code>, this is a wrapper around <code>gaussradau</code> from <code>FastGaussQuadrature</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Atomtomate/jDMFT.jl/blob/7b44f4eeaf5c8f29c2699c176ff0979a5d498755/src/Fourier.jl#LL76-L81">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="jDMFT.impSolve_IPT-Tuple{τFunction, τFunction, Vector{ComplexF64}, Float64, Float64}" href="#jDMFT.impSolve_IPT-Tuple{τFunction, τFunction, Vector{ComplexF64}, Float64, Float64}"><code>jDMFT.impSolve_IPT</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">impSolve_IPT(GWeiss_up::τFunction, GWeiss_do::τFunction, νnGrid::Vector{ComplexF64}, U::Float64, n::Float64)</code></pre><p>TODO: Documentation</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Atomtomate/jDMFT.jl/blob/7b44f4eeaf5c8f29c2699c176ff0979a5d498755/src/IPT.jl#LL12-L16">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="jDMFT.measure_GImp_τ-Tuple{jDMFT.Measurements, τFunction}" href="#jDMFT.measure_GImp_τ-Tuple{jDMFT.Measurements, τFunction}"><code>jDMFT.measure_GImp_τ</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">measure_GImp_τ(m::Measurements, GWeiss::τFunction)</code></pre><p>Measure impurity Green&#39;s function, after Monte Carlo samples have been accumulated in <code>m</code>, see also <a href="#jDMFT.Measurements"><code>Measurements</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Atomtomate/jDMFT.jl/blob/7b44f4eeaf5c8f29c2699c176ff0979a5d498755/src/CTINT_measure.jl#LL141-L146">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="jDMFT.riemann-Tuple{Real, Real, Int64}" href="#jDMFT.riemann-Tuple{Real, Real, Int64}"><code>jDMFT.riemann</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">riemann(start::Real, stop::Real, N::Int)</code></pre><p>Generate grid for Riemann sum integration from <code>start</code> to <code>stop</code> with <code>N</code> points. Returns <code>(weights, grid)</code></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Atomtomate/jDMFT.jl/blob/7b44f4eeaf5c8f29c2699c176ff0979a5d498755/src/Fourier.jl#LL68-L73">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="jDMFT.subtract_tail!-Union{Tuple{T}, Tuple{AbstractVector{T}, AbstractVector{T}, Vector{Float64}, Vector{ComplexF64}}} where T&lt;:Number" href="#jDMFT.subtract_tail!-Union{Tuple{T}, Tuple{AbstractVector{T}, AbstractVector{T}, Vector{Float64}, Vector{ComplexF64}}} where T&lt;:Number"><code>jDMFT.subtract_tail!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">subtract_tail(inp::AbstractVector{T}, c::Vector{Float64}, iω::Vector{ComplexF64})
subtract_tail!(outp::AbstractVector{Number}, inp::AbstractVector{Number}, c::Vector{Float64}, iω::Vector{ComplexF64})</code></pre><p>Subtract high frequency tail of function, i.e. <span>$f(i\omega_n) - \sum_l \frac{c_l}{i\omega_n^l}$</span>, with tail coefficients <code>c_l</code> and tail <code>iω</code>. One can use <a href="@ref"><code>iν_array</code></a> or <a href="@ref"><code>iω_array</code></a> to generate the grid. the inplace version stores the resulting data in <code>outp</code>.</p><p>TODO: this function is not optimized for performance</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Atomtomate/jDMFT.jl/blob/7b44f4eeaf5c8f29c2699c176ff0979a5d498755/src/GFTools.jl#LL138-L148">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="jDMFT.τGridTransform-Tuple{Real, Real, Vector{Float64}}" href="#jDMFT.τGridTransform-Tuple{Real, Real, Vector{Float64}}"><code>jDMFT.τGridTransform</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">τGridTransform(start::Float64, stop::Float64, grid::Vector{Float64})</code></pre><p>Transform integration grid from <code>[-1,1]</code> to <code>[start, stop]</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Atomtomate/jDMFT.jl/blob/7b44f4eeaf5c8f29c2699c176ff0979a5d498755/src/Fourier.jl#LL87-L91">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="jDMFT.τIndex-Tuple{Float64, Vector{Float64}, Float64}" href="#jDMFT.τIndex-Tuple{Float64, Vector{Float64}, Float64}"><code>jDMFT.τIndex</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">τIndex(τ::Float64, τGrid::Vector{Float64}, β::Float64)::Tuple{Int,Int}</code></pre><p>Internal function to determine nearest imaginary time value for <code>τGrid</code> of Green&#39;s function.  Find index for given <code>τ</code> that matches nearest value in <code>τGrid</code>. Returns <code>Tuple</code> with sign (since ``G(\tau + \beta) = - G(\tau)) and index. </p><p>TODO: no guaranteed to find nearest solution at index 1 and N</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Atomtomate/jDMFT.jl/blob/7b44f4eeaf5c8f29c2699c176ff0979a5d498755/src/GFTools.jl#LL115-L123">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="jDMFT.τIntegrate-Tuple{AbstractVector, Vector, Vector{Float64}}" href="#jDMFT.τIntegrate-Tuple{AbstractVector, Vector, Vector{Float64}}"><code>jDMFT.τIntegrate</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">τIntegrate(f::AbstractVector, τWeights::Vector, τGrid::Vector{Float64})
τIntegrate(f::Function, τWeights::Vector, τGrid::Vector{Float64})
τIntegrate(f::τFunction)</code></pre><p>Integrates <code>Vector</code> of values, <code>Function</code> or <code>τFunction</code> over <code>τGrid</code>, given <code>τWeights</code>.  Note, that you hav to transform any τ-spacing from the <code>[-1,1]</code> interval using <a href="#jDMFT.τGridTransform-Tuple{Real, Real, Vector{Float64}}"><code>τGridTransform</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Atomtomate/jDMFT.jl/blob/7b44f4eeaf5c8f29c2699c176ff0979a5d498755/src/Fourier.jl#LL94-L101">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="jDMFT.τ_to_ω-Tuple{τFunction, Vector{ComplexF64}}" href="#jDMFT.τ_to_ω-Tuple{τFunction, Vector{ComplexF64}}"><code>jDMFT.τ_to_ω</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">τ_to_ω(F::τFunction, fGrid::Vector{ComplexF64})</code></pre><p>Fourier transform from imaginary time to Matsubara space with a grid given bei <code>fGrid</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Atomtomate/jDMFT.jl/blob/7b44f4eeaf5c8f29c2699c176ff0979a5d498755/src/Fourier.jl#LL19-L23">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="jDMFT.ω_to_τ-Tuple{MatsubaraFunction, AbstractVector, AbstractVector}" href="#jDMFT.ω_to_τ-Tuple{MatsubaraFunction, AbstractVector, AbstractVector}"><code>jDMFT.ω_to_τ</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">ω_to_τ(F::MatsubaraFunction, τWeights::AbstractVector, τGrid::AbstractVector)</code></pre><p>Fourier transform from Matsubara frequencies to imaginary time with given <code>τGrid</code> and <code>τWeights</code> (for integration such as Gauss quadrature. See <a href="#jDMFT.τGridTransform-Tuple{Real, Real, Vector{Float64}}"><code>τGridTransform</code></a>, <a href="#jDMFT.gaussradau-Tuple{Real, Real, Int64}"><code>gaussradau</code></a> and <a href="#jDMFT.riemann-Tuple{Real, Real, Int64}"><code>riemann</code></a>).</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Atomtomate/jDMFT.jl/blob/7b44f4eeaf5c8f29c2699c176ff0979a5d498755/src/Fourier.jl#LL30-L34">source</a></section></article></article><nav class="docs-footer"><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 0.27.23 on <span class="colophon-date" title="Friday 28 October 2022 13:59">Friday 28 October 2022</span>. Using Julia version 1.7.3.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
